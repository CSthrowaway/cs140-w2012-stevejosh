                        +--------------------------+
                        |          CS 140          |
                        | PROJECT 2: USER PROGRAMS |
                        |      DESIGN DOCUMENT     |
                        +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Josh Parnell <parnell@stanford.edu>
Steve Lesser <sklesser@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

   	 	    ARGUMENT PASSING
		    ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

Originally, process_execute allocated a page of memory and copied
the filename to that page to pass it to the newly-executed process.
We use the same page to pass the arguments to the new process. In
start_process, we call start_process_parse_args, which sets up the
stack.

start_process_parse_args works by making an initial pass over the
arguments, calculating how many arguments exist and how much
whitespace there is. Using this information, we can then compute
the exact amount of memory required for the string data of argv
as well as the pointers of argv. Hance, at this point, we compute
how much total stack space we'll need. If it exceeds a page, we
return false and start_process reports failure. In this way, we
prevent overflow of the stack page.

After verifying that the memory requirements are reasonable, the
function copies all of the string data onto the stack in order
of appearance, while simultaneously wiring up the argv pointers
to the string data that is being written. This is only possible
because we pre-computed the memory requirements, so we know
exactly where everything should be on the stack.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

strtok is a poorly-thought-out function in the C library. The
primary concern is that it uses global data to TODO.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

   			      SYSTEM CALLS
			      ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

------------ In syscall.c ---------------

static struct lock filesys_lock;    /* Lock for file system access. */
static struct hash filesys_fdhash;  /* Hash table mapping fds to
                                       struct file*s. */

/* Gives the number of arguments expected for a given system
   call number. Useful to unify the argument-parsing code in
   syscall_handler. */
static uint8_t syscall_arg_count[] =
{
  0,      /* Halt */
  1,      /* Exit */
  1,      /* Exec */
  1,      /* Wait */
  2,      /* Create */
  1,      /* Remove */
  1,      /* Open */
  1,      /* FileSize */
  3,      /* Read */
  3,      /* Write */
  2,      /* Seek */
  1,      /* Tell */
  1       /* Close */
};


struct fdhash_elem
{
  struct hash_elem elem;
  int fd;
  struct file *file;
};

------------ In thread.h -----------------

/* States in a process' life cycle. 
   (Owned by userprog/process.c) */
enum process_status
  {
    PROCESS_INVALID,    /* Process does not exit. */
    PROCESS_STARTING,   /* Process has not yet started. */
    PROCESS_STARTED,    /* Process has successfully loaded. */
    PROCESS_FAILED,     /* Process failed to load. */
    PROCESS_DONE,       /* Process has terminated. */
    PROCESS_ORPHANED    /* The process' parent has died, so the process
                           must no longer try to report status changes
                           to the parent. */
  };

typedef int pid_t;

/* Owned by userprog/process.c. */
struct child_status
  {
    struct list_elem elem;              /* List element for adding this struct
                                           to a process' list of children. */
    pid_t pid;                          /* pid of the child process. */
    enum process_status status;         /* process status of the child. */
    int exit_code;                      /* Exit code of process, only valid
                                           if the process has already
                                           run and terminated. */
  };
struct thread
  {
#ifdef USERPROG
    /* Owned by userprog/process.c. */
    struct thread *parent;              /* Parent thread. */
    struct child_status *my_status;     /* Pointer to this thread's child_status
                                           block in the parent thread. */                                        
    struct list children;               /* Child processes of this thread. */
    struct lock child_changed_lock;     /* Lock associated with the condition
                                           variable below. */
    struct condition child_changed;     /* Condition variable for signalling
                                           that one of this thread's children
                                           has changed status. */
#endif
  }

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

The number of inspections depends on the type of data that is being
read. For a void* buffer (read/write), 2 inspections will always occur.
For a char* buffer, a maximum of NAME_MAX inspections will occur if
the string is associated with a file operator, but PGSIZE inspections
will occur if the string is associated with exec.

If the system call only copies 2 bytes of data, 2 inspections will
still occur for a void* buffer, and 2 inspections will occur for a
char* buffer.

There is some room for improvement in the number for char*s. Currently,
our scheme for validating null-terminated strings is very simple:
march along the string until a null-terminator is found, validating
each byte along the way. We could have done something fancier here by
recognizing that the address only needs to be validated if it lies on
a page boundary. We chose the simple route, however, since it would
be rather uncommon for huge strings to be passed to exec. Furthermore,
file-related strings are only validated up to a maximum of NAME_MAX
characters, so the performance loss for them is negligible. Overall,
we feel that the slight performance tradeoff is worth the simplicity
and safety of our implementation.

There is, of course, no room for improvement with fixed-size buffers:
we simply validate the head and the tail of the buffer.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

Our implementation of wait involves adding to the thread struct a
condition variable and lock, a list of
dynamically allocated process_child_status structures, a parent
pointer to the process parent, and a process_child_status pointer directly
to the to the parent's list element of the current process. 

The condition variable and lock allows for signalling between a child and 
a parent so a parent does not have to busy wait on a child in the wait 
function. The process_child_status structures
are used to store persistent information about a child to the parent that
created it. This information includes a process ID of the child process, a
process_status enum for specifying the state of the child process
(starting, started, failed, done), the return value of the child process
(only valid when process_status is failed or done) and a struct list_elem to
enable the structure to be included in the child list of it's creator. The
additional process_child_status pointer allows a thread to have direct
access to it's parents list element of the process_child_status
corresponding to the current child process. We added this for optimization reasons so there
were not unnecessary traversals through lists of child processes when a
thread wanted to update information about it's own process_child_status.

Upon process termination, a global process_dying lock is acquired to avoid
race conditions of competing process terminations then the process's
personal process_child_status is updated to reflect the final exit code
and process_status. The terminating process is then free to signal it's
parent's lock to release potential waits. The thread can now remove itself as usual
since it's exit status is safe in the persistent process_child_status
element of it's parent.


>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We did not change this mapping. We felt that the simplicity of the
mapping was a big win, and could see no advantages in straying from
it.

      	     SURVEY QUESTIONS
	     ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

It was very unclear to us what the following means;
"You should implement the standard Unix semantics for files. That is,
when a file is removed any process which has a file descriptor for that
file may continue to use that descriptor. [...] "

It is very unclear how much of this already exists. We did some digging
and found that the filesystem inodes already support a reference-counting
mechanism, but, annoyingly, that the directory layer does not make use
of this mechanism (why!?!?). Given that we were advised not to touch
the file system code, it seemed that the best choice was to write another
reference-counting mechanism at the syscall layer. We're still unsure if
this was the intent of the assignment.

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
