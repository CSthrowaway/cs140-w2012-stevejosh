                        +---------------------------+
                        |          CS 140           |
                        | PROJECT 3: VIRTUAL MEMORY |
                        |      DESIGN DOCUMENT      |
                        +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Josh Parnell <parnell@stanford.edu>
Steve Lesser <sklesser@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

   	 	 PAGE TABLE MANAGEMENT
                 =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

We maintain a supplemental page table of entries that each contain a
pointer corresponding to the frame containing the page's data. Note that
the frame needn't be in physical memory for the pointer to be valid. We
maintain this supplemental page table as a hash table. To find the frame
that contains the data of a given virtual address, we perform a hash table
lookup to find the supplemental page table entry corresponding to the given
virtual address, then examine the frame pointer within this entry.

If the data exists in physical memory, then frame->paddr will be non-null.
Otherwise, frame->paddr is NULL, but frame still contains all of the
necessary information to load the data back into memory upon requestion.
That is to say that the frame structure holds information about whether a
page is zeroed, swapped, or mmapped, as well as additional details specific
to the current mode of storage.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We avoid this issue altogether by operating in the user virtual address
space at all times. Our system call infrastructure makes exclusive use of
user-space virtual addresses, such that we do not have to deal with kernel
aliasing.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

frame_page_in, which handles our demands for frames, requires that processes
acquire the frame_lock before touching the main list of frames or the clock
hand variable. Races are avoided by protected access to these shared
structures with a lock. Note that we also force a process to release the lock
while it writes a dirty page back to disk (so that other processes can proceed
if they do not require I/O).

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

Our choice of supplemental page entry structure is simple and clean.
It simply maps a virtual page address to a frame. This allows the page
entries to remain relatively lightweight and easy to manage due to their
simplicity.

On the other hand, we perform much of the heavy-lifting of this assignment
with our frame structure, which encapsulates far more than just a slot in
physical memory. Frames contain information about whether their data is
zero-filled, swapped, or mmapped, and also hold information about swap slot,
mmap ids, etc. Essentially, we chose frame to mean "a page of data that is
generated and stored in a certain way, and may or may not be mapped to
physical memory at this time." The motivation for making the frame meatier
than the supplemental page entries was primarily to more elegantly support
frame sharing between processes, which, unfortunately, we did not get around
to in the end. However, we still feel that our design decisions made
management of pages and frames quite conceptually simple.

   		       PAGING TO AND FROM DISK
                       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

When we want to evict a frame (frame_choose_eviction) we iterate through
the frames_allocated list starting from our globally stored cursor
and wrapping around the end into the front. We evict the first
frame which was not accessed by any pages pointing at it and is not
pinned. As we check each frame's page for whether it
has been accessed we reset the accessed bit to be not accessed. This
algorithm is equivalent to the clock algorithm.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

When the frame that was previously used by process Q is evicted the frame
stays connected to the page table but it's physical address becomes NULL
and it is removed from the frames_allocated list and the entry in the
process's page table is also removed. Then when a page in process P uses
the physical memory that Q was previously using it updates it's frame
structure to point to that physical memory. and adds itself to the
frames_allocated list. The supplementary page table does not need to be
updated (unless the page has not been accessed before in which case the
page_table_entry is added and a new frame is created). 

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

First, on page faults we can look at the stack pointer by looking at
either the intr_frame or the stored stack pointer in the current thread
struct depending on whether the exception occurred in user mode or not. We
then check if the fault address is less than (stack_pointer - 32), if it is
then the access is invalid and the process is released. Otherwise if the
fault address is also less than the PHYS_BASE then it is a valid virtual
address and a new page entry is created.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

There are two types of locks, the single global frame lock and the per
process supplementary page table locks. The global frame_lock controls
creation and eviction of frames in addition to any operations on the
global frames_allocated list which is a list of all frames which currently
are currently loaded into physical memory. The per process supplementary
page table locks are used to ensure any changes to the local page table
attributes are safe and cause minimal waiting since other threads should
not have to wait for updating attributes on an unrelated thread's page
table.

There are at most two locks acquired with one of them being the
frame_lock and the other being a page table lock. The frame_lock is always 
acquired first. With these two conditions we are ensured there are no
orderings of lock acquires which create a circularity of
requests/ownership. Without circularity of ownership deadlocks are
avoided.

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?



---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

For different parts of the VM system we use different numbers of
locks. For controlling the creation, eviction, and loading of frames there
is a single frame_lock due to the global nature of frames which can be
accessed by multiple processes. We thought this seemed the safest approach
for ensuring multiple processes would not run into race conditions from
sharing the same global frame pool. For controlling the insertion and
removal of elements in the supplementary page tables, we use per-process
locks built into the page_table struct which is a part of every thread
struct. We didn't think it was appropriate for updating any single
process's page table to cause all other processes to wait, hence we split
the lock up per process.

   	      MEMORY MAPPED FILES
              ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

Memory mapped pages are marked by the frame associated with the page
having an mmap flag set in addition to three auxilary pieces of
information: the mmapid, the offset into the file of the start of the
frame, and the amount of the page which is still part of the file (PGSIZE
except for the last page).

On a page fault of a mmapped page a valid physical address is obtained
and then the file information found in the frame struct is used to read
the relevant part of the file into the physical address. If the remaining
part of the file to be read in is less than a page in size then the rest
of the page after the valid file parts is set to be 0. This is similar to
reading in swap pages but the source is the file system instead
of swap space. Additionally the relevant amount of the file has to be
considered to potentially pad the end of a frame with 0's.

When a mmapped page is evicted the pages referencing the relevant frame
are checked if any of them are dirty. If any of them are dirty, then the the frame is
written out to the original file using the auxilary data found in the
frame struct to know which file and how much of the file to write
out. This differs from the swap pages only in the destination of the
writing and in accounting for the final page in a file which may write out
less than a full page of data.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

Before creating the supplementary page table entries required for the
mmap, all the necessary pages are walked through and made sure there is
not an already existing entry in the current page table. Only once all the
pages are ensured to be uninitialized then all the supplementary page
table entries are created. This whole process is done while locked under
the per-process supplementary page table lock to ensure no new pages are
added to the current process during this time.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

Our mmap and executable demand-paged data does share a lot of
implementation, in fact our executable loading uses the mmap functionality
but just a different way of allocating the pages used. Each page required
by the executable is inserted into the page table as an mmap page with
FRAME_READONLY and FRAME_CODE flags set. Since each frame independently knows the
mmapid, offset into the file, and amount of valid file they require, they can be lazily
constructed and are incrementally added to the supplementary page table as
the executable is scanned. This is a little different than the
construction of an mmaped file made from a system call- which creates all
the required pages at once in sequential order. However, once the
executable is loaded or the system call mmap completes then 
the two types types of mapped memory are not treated differently.


       	      SURVEY QUESTIONS
              ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
